#- setup variable for cluster installation

# Kubernetes cluster variables
kube:
  version: "v1.12.4"
  config_dir: /etc/kubernetes
  manifests_dir: "/etc/kubernetes/manifests"
  cert_dir: "/etc/kubernetes/pki"
  addon_dir: "/etc/kubernetes/addon"
  master_cert_dir: /opt/kubernetes/pki
  flannel_dir: /etc/sysconfig
  admin_config: "/etc/kubernetes/kubeadminconfig"
  # Cluster service ip range
  service_subnet: 10.96.0.0/24
  # IP of default kubernetes service, it is the first IP of service network CIDR range
  service_ip: 10.96.0.1

#- image and other variable
api_image: gcr.io/google_containers/kube-apiserver-amd64:v1.12.4
controller_image: gcr.io/google_containers/kube-controller-manager-amd64:v1.12.4
scheduler_image: gcr.io/google_containers/kube-scheduler-amd64:v1.12.4
kube_proxy_image: gcr.io/google_containers/kube-proxy-amd64:v1.12.4
etcd_image: k8s.gcr.io/etcd:3.2.24

#- all certifactes for cluster  
ca_cert: /etc/kubernetes/pki/ca.pem
ca_key: /etc/kubernetes/pki/ca-key.pem
admin_key: /etc/kubernetes/pki/admin-key.pem
admin_cert: /etc/kubernetes/pki/admin.pem
node_cert: /etc/kubernetes/pki/node.pem
node_key: /etc/kubernetes/pki/node-key.pem
controller_cert: /etc/kubernetes/pki/controller.pem
controller_key: /etc/kubernetes/pki/controller-key.pem
scheduler_cert: /etc/kubernetes/pki/scheduler.pem
scheduler_key: /etc/kubernetes/pki/scheduler-key.pem

# Use keepalived for API HA. If there is only one master node, then set 'enabled' to false.
keepalived:
  enabled: true
  interface: "{{ ansible_default_ipv4.interface }}"
  shared_ip: 10.1.0.100		# Virtual IP
  vrid: 110			# Virtual Router ID
  adv_interval: 1		# VRRP advert interval
  authtype: PASS		# 'PASS' (simple password) or 'AH' (IPSEC)
  password: k8s@123		# password for accessing VRRP

#- kubeconfig file 
kubeadminconfig: /etc/kubernetes/kubeadminconfig

# all master fqdn name - it require to create ssl certificate
# set it to only available api server
masters_fqdn: ['tkube1.test.com', 'tkube2.test.com', 'tkube3.test.com']
domain_name: test.com #- use to create wildcard ssl certificate for api and etcd

#- cluster dns name and IP
cluster_name: cluster.local

#- api authorization RBAC
auth_mode: Node,RBAC

# kube-proxy addon
kube_proxy: true # set true only if cluster is fully operation and running

#- kube-dns add-on
kube_dns: true # set true only if cluster is fully operation and running
#- if true then set following
dns_ip: 10.96.0.10	# IP-address should be from {{ kube.service_subnet }} range
dns_replicas: 1

#flannel network # only one network plugin should be enable either weave or flannel
flannel: true
flannel_network: "10.244.0.0/16"

#-metrics-server
metrics_server: true

# Setup haproxy for Kubernetes API loadbalancing
haproxy:
  enabled: true                 # Set to false when already physical loadbalancer available
  config_dir: /etc/haproxy
  monitor_port: 9090
  admin_user: admin
  admin_password: admin123

# kube-api server settings
kube_api:
  interface: "{{ ansible_default_ipv4.interface }}"
  secure_port: 6443
  url: "https://{{ keepalived.shared_ip }}"             # Should be haproxy host IP or network load balancer IP. If you use only one api server then setup its IP.

# etcd config
etcd:
  interface: "{{ ansible_default_ipv4.interface }}"
  client_port: 2379
  peer_port: 2380
  conf_dir: /etc/etcd
  data_dir: /var/lib/etcd
  peers_group: etcd
  peer_url_scheme: https
  initial_cluster_state: new
  initial_cluster_token: etcd-k8-cluster
  ssl_ca_file: "{{ kube.cert_dir }}/ca.pem"
  ssl_cert_file: "{{ kube.cert_dir }}/etcd.pem"
  ssl_key_file: "{{ kube.cert_dir }}/etcd-key.pem"
  ssl_peer_ca_file: "{{ kube.cert_dir }}/ca.pem"
  ssl_peer_cert_file: "{{ kube.cert_dir }}/etcd.pem"
  ssl_peer_key_file: "{{ kube.cert_dir }}/etcd-key.pem"

# If you have local mirror with Docker packages, you can use it for deploy
# docker_repo: "deb [arch=amd64] http://repo.internal/docker/bionic/ ubuntu stable"
# docker_repo_key: http://repo.internal/repo-key.asc
#    or
# docker_repo: "http://repo.internal/linux/centos/docker-ce.repo"

# If you want to use containerd instead of docker, set "containerd.enabled" to true
containerd:
  enabled: false
  version: 1.2.2
# fetch_uri: "http://some.mirror.internal/containerd-1.2.2.linux-amd64.tar.gz"

cni:
  version: v0.7.4
  bin_dir: /opt/cni/bin/
  conf_dir: /etc/cni/net.d/
# fetch_uri: "http://some.mirror.internal/cni-plugins-amd64-v0.7.4.tgz"
